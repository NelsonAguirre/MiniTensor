from dataclasses import dataclass
from typing import ClassVar, List, Optional, Protocol, Tuple, Union, runtime_checkable, Any
from .device import Device, DType, Scalar, Array

Data = Union[Scalar, Array, list, "TensorLike"]
Index = Union[int, slice, List[int], Tuple[Union[int, slice]], Array]
Shape = Tuple[int, ...]
Dim = Union[int, Tuple[int, ...]]


@dataclass
class TProps:
    r"""Base properties shared by tensor classes.

    Attributes:
        _data (Vector): Raw tensor data.
        requires_grad (bool): Whether the tensor requires gradient tracking.
        dependencies (List[TensorType]): List of dependency nodes for autograd.
        device (Device): The device (CPU, GPU, etc.) where the tensor is located.
        dtype (DType): The data type of the tensor values.
    """

    data: Array
    dtype: DType = DType.FLOAT32
    requires_grad: bool = False
    device: Union[Device, str] = Device.CPU
    grad_fn: Optional["FunctionLike"] = None
    in_graph: Optional[bool] = None

    def props(self) -> Tuple:
        return (
            self.data,
            self.dtype,
            self.requires_grad,
            self.device,
            self.grad_fn,
            self.in_graph,
        )


@runtime_checkable
class FunctionLike(Protocol):
    @property
    def dependencies(self) -> Tuple["TensorLike", ...]: ...

    def backward(self, grad: Array) -> Union[Tuple[Array, Array], Array]: ...


@runtime_checkable
class TensorLike(Protocol):
    # --- DType aliases ----
    float64: ClassVar[DType]
    float32: ClassVar[DType]
    int64: ClassVar[DType]
    int32: ClassVar[DType]
    int16: ClassVar[DType]
    int8: ClassVar[DType]
    bool_: ClassVar[DType]

    @classmethod
    def from_TProps(cls, props: TProps) -> "TensorLike": ...

    # --- Core Properties ---

    @property
    def grad_fn(self) -> Optional[FunctionLike]: ...

    @grad_fn.setter
    def grad_fn(self, grad_fn): ...

    @property
    def data(self) -> Array: ...

    @data.setter
    def data(self, new_data: Array) -> None: ...

    @property
    def requires_grad(self) -> bool: ...

    @requires_grad.setter
    def requires_grad(self, value: bool): ...

    @property
    def device(self) -> Device: ...

    @device.setter
    def device(self, device: Device): ...

    @property
    def dtype(self) -> DType: ...

    @dtype.setter
    def dtype(self, value: DType): ...

    @property
    def is_leaf(self) -> bool: ...

    def item(self) -> Scalar: ...

    @staticmethod
    def build_ndarray(
        data: Data, dtype: DType = DType.FLOAT32, device: Device = Device.CPU
    ) -> Array: ...

    # --- Shape Properties ---

    @property
    def shape(self) -> Shape: ...

    @property
    def ndim(self) -> int: ...

    @property
    def size(self) -> int: ...

    def __repr__(self) -> str: ...
    def __str__(self) -> str: ...

    def to(self, device: Union[Device, str], dtype: Optional[DType] = None) -> "TensorLike": ...

    @property
    def in_graph(self) -> bool: ...

    def in_graph_set(self): ...

    def zero_grad(self): ...

    def backward(self, grad_output: Optional["TensorLike"] = None): ...

    @staticmethod
    def randn(
        dims: Dim = (),
        requires_grad=False,
        device: Device = Device.CPU,
    ) -> "TensorLike": ...

    # --- Unary / Structure Methods ---
    def reshape(self: "TensorLike", shape: Shape) -> "TensorLike": ...
    def transpose(self: "TensorLike", dim: Optional[Dim]) -> "TensorLike": ...
    def squeeze(self: "TensorLike", dim: Optional[Dim]) -> "TensorLike": ...
    def unsqueeze(self: "TensorLike", dim: int) -> "TensorLike": ...
    @property
    def T(self: "TensorLike") -> "TensorLike": ...

    # --- Indexing ---
    def __getitem__(self: "TensorLike", index: Index) -> "TensorLike": ...

    # --- Where Logic ---
    @staticmethod
    def where(condition: "TensorLike", a: "TensorLike", b: "TensorLike") -> "TensorLike": ...
    @staticmethod
    def maximum(a: "TensorLike", b: "TensorLike") -> "TensorLike": ...
    @staticmethod
    def minimum(a: "TensorLike", b: "TensorLike") -> "TensorLike": ...
    def sign(self: "TensorLike") -> "TensorLike": ...
    def masked_fill(self: "TensorLike", mask: "TensorLike", value: float) -> "TensorLike": ...
    def threshold(self: "TensorLike", threshold: float, value: float) -> "TensorLike": ...

    # --- Comparisons ---
    def __eq__(self: "TensorLike", other: Any) -> "TensorLike": ...  # type: ignore
    def __ne__(self: "TensorLike", other: Any) -> "TensorLike": ...  # type: ignore
    def __lt__(self: "TensorLike", other: "TensorLike") -> "TensorLike": ...
    def __le__(self: "TensorLike", other: "TensorLike") -> "TensorLike": ...
    def __gt__(self: "TensorLike", other: "TensorLike") -> "TensorLike": ...
    def __ge__(self: "TensorLike", other: "TensorLike") -> "TensorLike": ...

    # --- Unary Math Ops ---
    def exp(self: "TensorLike") -> "TensorLike": ...
    def log(self: "TensorLike") -> "TensorLike": ...
    def tanh(self: "TensorLike") -> "TensorLike": ...
    def abs(self: "TensorLike") -> "TensorLike": ...
    def sqrt(self: "TensorLike") -> "TensorLike": ...

    # --- Reduction Ops ---
    def sum(self: "TensorLike", dim: Optional[Dim], keepdims: bool = False) -> "TensorLike": ...
    def mean(self: "TensorLike", dim: Optional[Dim], keepdims: bool = False) -> "TensorLike": ...
    def min(self: "TensorLike", dim: Optional[Dim], keepdims: bool = False) -> "TensorLike": ...
    def max(self: "TensorLike", dim: Optional[Dim], keepdims: bool = False) -> "TensorLike": ...

    # --- Binary Ops ---
    def __matmul__(self: "TensorLike", other: Data) -> "TensorLike": ...
    def __imatmul__(self: "TensorLike", other: Data) -> "TensorLike": ...
    def __add__(self: "TensorLike", other: Data) -> "TensorLike": ...
    def __radd__(self: "TensorLike", other: Data) -> "TensorLike": ...
    def __iadd__(self: "TensorLike", other: Data) -> "TensorLike": ...
    def __sub__(self: "TensorLike", other: Data) -> "TensorLike": ...
    def __rsub__(self: "TensorLike", other: Data) -> "TensorLike": ...
    def __isub__(self: "TensorLike", other: Data) -> "TensorLike": ...
    def __mul__(self: "TensorLike", other: Data) -> "TensorLike": ...
    def __rmul__(self: "TensorLike", other: Data) -> "TensorLike": ...
    def __imul__(self: "TensorLike", other: Data) -> "TensorLike": ...
    def __pow__(self: "TensorLike", other: Data) -> "TensorLike": ...
    def __rpow__(self, other: Data) -> "TensorLike": ...
    def __ipow__(self, other: Data) -> "TensorLike": ...
    def __truediv__(self: "TensorLike", other: Data) -> "TensorLike": ...
    def __rtruediv__(self: "TensorLike", other: Data) -> "TensorLike": ...
    def __itruediv__(self: "TensorLike", other: Data) -> "TensorLike": ...
    def __neg__(self: "TensorLike") -> "TensorLike": ...
